# Memory Paging
## Concept of Paging
- Paging **splits up** address space into **fixed-size** unit called a **page**
    - Segmentation: variable size of logical segments (code, stack, heap, etc.)
- With paging, **physical memory** is also **split** into some number of pages called a **page frame**
    - page frame: sometimes referred to as physical and virtual page
- **Page table** per process is needed **to translate** the virtual address to physical address

## Advantages of Paging
- **Flexibility**: Supporting the abstraction of address space effectively
    - Don't need assumption how heap and stack grow and are used
- **Simplicity**: easy of free-space management
    - The page in address space and the page frame are the same size
    - Easy to allocate and keep a free list

### Example: A Simple Paging
- 128-byte physical memory with 16 bytes page frames
- 64-byte address space with 16 bytes pages

- The pages in the page frame do not have to be in any specific order
    - Just have to know the address (virtual to physical address mapping stored in the page table)

## Address Translation
- Two components in the virtual address
    - VPN: virtual page number
    - Offset: offset within the page
- Handled in MMU
    - Memory Management Unit

> Va5 Va4 Va3 Va2 Va1 Va0
- VPN = Va5 Va4
- Offset = Va3 Va2 Va1 Va0

- Example: virtual address 21 in 64-byte address space
> 0  1  0  1  0  1
- 0 1: VPN
- 0 1 0 1: offset

- VPN goes through Address translation
    - provides PFN in physical address

0 1 $\rightarrow$ 1 1 1

- Physical Address
> 1 1 1 0 1 0 1

## Where are page tables stored?
- Page tables can get awfully large
    - 32-bit address space with 4-KB pages, 20 bits for VPN
        - 4MB = $2^{20}$ entries * 4 Bytes per page table entry
- Page tables for each process are stored in memory

- 4kb process and 32bit Page address
- remove the 12bit offset, so 20 bits need to be stored
- since 4kb, store in multiples of 4 bits

## What is in the Page Table?
- The page table is just a **data structure** that is used to map the virtual address to physical address
    - Simplest form: a linear page table, an array
- The OS **indexes** the array by VPN, and looks up the page-table entry

## Common Flags of Page Table Entry
- `Valid Bit`(1Bit): Indicating whether the particular translation is valid
- `Protection Bit`(3Bits): Indicating whether the page could be read from, written to, or executed from
- `Present Bit`(1Bit): Indicating whether this page is in physical memory or on disk (swapped out)
- `Dirty Bit`(1Bit): Indicating whether the page has been modified since it was brought into memory
    - CPU sets and clears this bit
- `Reference Bit (Accessed Bit)`(1Bit): Indicating that a page has been accessed
    - CPU sets and clears this b it

```
important
```
> 27bit needed, now including the 5 bit offset, 32bit needed per page entry

### Example: x86 Page Table Entry
- P: Present [ 0 ]
- R/W: Read/write bit [ 1 ]
- U/S: supervisor [ 2 ]
- A: accessed bit [ 5 ]
- D: dirty bit [ 6 ]
- PFN: the page frame number [12 - 31]

## Paging: Too Slow
- To find a location of the desired PTE, the **starting location** of the page table is **needed**
- For every memory reference, paging requires the OS to perform one **extra memory reference**
- page table entry: 32bit
- page: 4kb
- page table: 4mb

## Accessing Memory with Paging
```c
// Extract the VPN from the virtual address
VPN = (virtualAddress & VPN_MASK) >> SHIFT

//Form the address of the page-table entry (PTE)
// page table base register (PTBR)
PTEAddr = PTBR + (VPN * sizeof(PTE))

// Fetch the PTE
PTE = AccessMemory(PTE Addr)

// Check if process can access the page
if (PTE.Valid == False)
    RaiseException(SEGMENTATION FAULT)
else if (CanAccess(PTE.ProtectBITS) == False)
    RaiseException (PROTECTION_FAULT)
else
    // Access is OK: form physical address and fetch it
    offset = VirtualAddress & OFFSET_MASK
    PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
    Register = AccessMemory(PhysAddr)
```
## A Memory Trace
- Example: A Simple Memory Access
```c
int array[1000];
...
for (i = 0; i < 1000; i++)
    array[i] = 0;
```
- Compile and execute
```c
prompt> gcc -o array array.c -Wall -o
prompt> ./array
- Resulting Assembly code
```c
0x1024 movl $0x0, (%edi, %eax, 4)
0x1028 incl %eax
0x102c cmpl $0x03e8, %eax
0x1030 jne 0x1024
```

- Each code has at least 4 memory access
    - mov
        - 2 memory access for memory
        - searching target memory access 2 times
- Each instruction has one page table access and memory access to the actual instruction code