# Memory and Address Space
## Memory Virtualization
- OS virtualizes its physical memory
- OS provides an illusion memory space per each process
- It seems to be seen like each process uses the whole memory

> physical memory: memory chip

### Benefits
- Ease of use in programming
- Memory efficiency in terms of **times** and **space**
- The guarantee of isolation for processes as well as OS
    - Protection from ``errant accesses`` of other processes
>errant access: seeping into another process' memory

## OS in the Early System
- Load only one process in memory
    - Poor utilization and efficiency

### Multiprogramming and Time Sharing
- ``Load multiple processes`` in memory
    - Execute one for a short while
    - Switch processes between them in memory
    - Increase utilization and efficiency
- Cause an important **protection issue**
    - Errant memory accesses from other processes

### Address Space
- OS creates an abstraction of physical memory
    - The address space contains all about a running process
    - That consists of program code, heap, stack, etc.

- Code
    - Where instructions live
- Heap
    - Dynamically allocate memory
        - malloc in C language
        - new in object-oriented language
- Stack
    - Store return addresses or values
    - Contain local variables arguments to routines

### Virtual Address
- **Every address** in a running program is virtual
    - OS translates the birtual address

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[]){
    printf("location of code : %p\n", (void *) main);
    printf("location of heap : %p\n", (void *) malloc(1));
    int x = 3;
    printf("location of stack : %p\n", (void *) &x);
    return x;
}
```
- The output in 64-bit Linux machine
```
location of code : 0x40057d
location of heap : 0xcf2010
location of stack : 0x7fff9ca45fcc
```
### Memory API
#### malloc()
```c
#include <stdlib.h>

void* malloc(size_t size)
```
- Allocate a memory region on the heap
- Argument
    - size_t size: size of the memory block (in bytes)
    - size_t is an unsigned integer type
- Return
    - Success: a void type pointer to the memory block allocated by malloc
    - Fail: a null pointer

- malloc
    - library call
    - when heap has enough freespace
        - malloc only manages heapspace
    - when heap is not enough, malloc calls brk

    - [brk (break)](#system-calls-for-allocation)
        - system call
        - increase the break size (heap size)
        - Once increases, it does not get smaller

    - Once malloc increases through brk, heap space increases but never decreases

#### sizeof()
- Routines and macros are utilized for *size* in *malloc* instead typing in a number directly
- Two types of results of *sizeof* with variables
    - The actual size of 'x' is known at run-time
```c
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x)); //4
```
- The actual size of 'x' is known at compile-time
```c
int x[10];
printf("%d\n", sizeof(x)); //40
```

#### free()
```c
#include <stdlib.h>

void free(void* ptr)
```

- Free a memory region allocated by a call to *malloc*
- Argument
    - void *ptr: a pointer to a memory block allocated with malloc
- Return
    - none

### Memory Allocating
```c
int *pi; //local variable

pi = (int *)malloc(sizeof(int) * 4);
```

### Memory Freeing
```c
free(pi);
```

### Forgetting to Allocate Memory
- Incorrect code
```c
char *src = "hello"; //character string constant
char *dst; //unallocated
strcpy(dst, src); //segfault and die
```

- Correct code
```c
char *src = "hello"; //character string constant
char *dst (char *)malloc(strlen(src) + 1); //allocated
strcpy(dst, src); //work properly
```

### Not Allocating Enough Memory
- Incorrect code, but work properly
```c
char *src = "hello"; //character string constant
char *dst (char *)malloc(strlen(src)); // too small
strcpy(dst, src); //work properly

// \0 (NULL) omitted
```

### Forgetting to Initialize
- Encounter an uninitialized read
```c
int *x = (int *)malloc(sizeof(int)); //allocated

printf("*x = %d\n", *x); //uninitialized memory access
```

### Memory Leak
- A program runs out of memory and eventually dies
    - Run out of memory

### Dangling Pointer
- Freeing memory before it is finished using
    - A program accesses to memory with an invalid pointer

### Other Memory APIs: calloc()
```c
#include <stdlib.h>

void *calloc(size_t num, size_t size)
```

- Allocate memory on the heap and zeroes it before returning
- Argument
    - size_t num: number of blocks to allocate
    - size_t size: size of each block (in bytes)
- Return
    - Success: a void type pointer to the memory block allocated by calloc
    - Fail: a null pointer

### Double Free
- Free memory that was freed already
    - Undefined Error
```c
int *x = (int *)malloc(sizeof(int)); // allocated
free(x); // free memory
free(x); // free repeatedly

//undefined error
```

### Other Memory APIs: realloc()
```c 
#include <stdlib.h>

void *realloc(void *ptr, size_t size)
```
- Change the size of memory block
    - A pointer returned by realloc may be either the same as ptr or a new
- Argument
    - void *ptr: Pointer to memory block allocated with malloc, calloc or realloc
    - size_t size: New size for the memory block (in bytes)
- Return
    - Success: void type pointer to the memory block
    - Fail: null pointer

### System Calls for Allocation
```c
#include <unistd.h>

int brk(void *addr)
void *sbrk(intptr_t increment);
```

- malloc library call use brk system call
    - brk is called to expand the program's break
        - break: The location of the end of the heap in address space
    - sbrk is an additional call similar with brk
    - Programmers **should never directly call** either brk or sbrk

### System Calls for Memory Mapping
```c
#include <sys/mman.h>

void *mmap(void *ptr, size_t length, int port, int flags, int fd, off_t offset)
```

- mmap system call can create **an anonymous** memory region