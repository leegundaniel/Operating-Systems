# Memory and Address Space
## Memory Virtualization
- OS virtualizes its physical memory
- OS provides an illusion memory space per each process
- It seems to be seen like each process uses the whole memory

> physical memory: memory chip

### Benefits
- Ease of use in programming
- Memory efficiency in terms of **times** and **space**
- The guarantee of isolation for processes as well as OS
    - Protection from ``errant accesses`` of other processes
>errant access: seeping into another process' memory

## OS in the Early System
- Load only one process in memory
    - Poor utilization and efficiency

### Multiprogramming and Time Sharing
- ``Load multiple processes`` in memory
    - Execute one for a short while
    - Switch processes between them in memory
    - Increase utilization and efficiency
- Cause an important **protection issue**
    - Errant memory accesses from other processes

### Address Space
- OS creates an abstraction of physical memory
    - The address space contains all about a running process
    - That consists of program code, heap, stack, etc.

- Code
    - Where instructions live
- Heap
    - Dynamically allocate memory
        - malloc in C language
        - new in object-oriented language
- Stack
    - Store return addresses or values
    - Contain local variables arguments to routines

### Virtual Address
- **Every address** in a running program is virtual
    - OS translates the birtual address

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[]){
    printf("location of code : %p\n", (void *) main);
    printf("location of heap : %p\n", (void *) malloc(1));
    int x = 3;
    printf("location of stack : %p\n", (void *) &x);
    return x;
}
```
- The output in 64-bit Linux machine
```
location of code : 0x40057d
location of heap : 0xcf2010
location of stack : 0x7fff9ca45fcc
```
### Memory API
#### malloc()
```c
#include <stdlib.h>

void* malloc(size_t size)
```
- Allocate a memory region on the heap
- Argument
    - size_t size: size of the memory block (in bytes)
    - size_t is an unsigned integer type
- Return
    - Success: a void type pointer to the memory block allocated by malloc
    - Fail: a null pointer

- malloc
    - library call
    - when heap has enough freespace
        - malloc only manages heapspace
    - when heap is not enough, malloc calls brk

    - [brk (break)](#system-calls-for-allocation)
        - system call
        - increase the break size (heap size)
        - Once increases, it does not get smaller

    - Once malloc increases through brk, heap space increases but never decreases

#### sizeof()
- Routines and macros are utilized for *size* in *malloc* instead typing in a number directly
- Two types of results of *sizeof* with variables
    - The actual size of 'x' is known at run-time
```c
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x)); //4
```
- The actual size of 'x' is known at compile-time
```c
int x[10];
printf("%d\n", sizeof(x)); //40
```

#### free()
```c
#include <stdlib.h>

void free(void* ptr)
```

- Free a memory region allocated by a call to *malloc*
- Argument
    - void *ptr: a pointer to a memory block allocated with malloc
- Return
    - none

### Memory Allocating
```c
int *pi; //local variable

pi = (int *)malloc(sizeof(int) * 4);
```

### Memory Freeing
```c
free(pi);
```

### Forgetting to Allocate Memory
- Incorrect code
```c
char *src = "hello"; //character string constant
char *dst; //unallocated
strcpy(dst, src); //segfault and die
```

- Correct code
```c
char *src = "hello"; //character string constant
char *dst (char *)malloc(strlen(src) + 1); //allocated
strcpy(dst, src); //work properly
```

### Not Allocating Enough Memory
- Incorrect code, but work properly
```c
char *src = "hello"; //character string constant
char *dst (char *)malloc(strlen(src)); // too small
strcpy(dst, src); //work properly

// \0 (NULL) omitted
```

### Forgetting to Initialize
- Encounter an uninitialized read
```c
int *x = (int *)malloc(sizeof(int)); //allocated

printf("*x = %d\n", *x); //uninitialized memory access
```

### Memory Leak
- A program runs out of memory and eventually dies
    - Run out of memory

### Dangling Pointer
- Freeing memory before it is finished using
    - A program accesses to memory with an invalid pointer

### Other Memory APIs: calloc()
```c
#include <stdlib.h>

void *calloc(size_t num, size_t size)
```

- Allocate memory on the heap and zeroes it before returning
- Argument
    - size_t num: number of blocks to allocate
    - size_t size: size of each block (in bytes)
- Return
    - Success: a void type pointer to the memory block allocated by calloc
    - Fail: a null pointer

### Double Free
- Free memory that was freed already
    - Undefined Error
```c
int *x = (int *)malloc(sizeof(int)); // allocated
free(x); // free memory
free(x); // free repeatedly

//undefined error
```

### Other Memory APIs: realloc()
```c 
#include <stdlib.h>

void *realloc(void *ptr, size_t size)
```
- Change the size of memory block
    - A pointer returned by realloc may be either the same as ptr or a new
- Argument
    - void *ptr: Pointer to memory block allocated with malloc, calloc or realloc
    - size_t size: New size for the memory block (in bytes)
- Return
    - Success: void type pointer to the memory block
    - Fail: null pointer

### System Calls for Allocation
```c
#include <unistd.h>

int brk(void *addr)
void *sbrk(intptr_t increment);
```

- malloc library call use brk system call
    - brk is called to expand the program's break
        - break: The location of the end of the heap in address space
    - sbrk is an additional call similar with brk
    - Programmers **should never directly call** either brk or sbrk

### System Calls for Memory Mapping
```c
#include <sys/mman.h>

void *mmap(void *ptr, size_t length, int prot, int flags, int fd, off_t offset)
```

- mmap system call can create **an anonymous** memory region

- Private mode
    - When writing on file, only written in the stack, memory not updated
    - only stored in the "app"
- Shared
    - when writing on file, the memory will also be updated, after the buffer

### Memory Virtualization with Efficiency and Control
- memory virtualizing takes a similar strategy known as **limited direct execution (LDE)** for efficiency and control
- In memory virtualizing, efficiency and control are attained by `hardware support`
    - e.g., registers, TLB (Translation Look-aside Buffer)s, page-table

### Address Translation
- Hardware transform a **virtual address** to a **physical address**
    - The desired information is actually stored in a physical address
- The OS must get involved at key points to set up the hardware
    - The OS must manage memory to judiciously intervene

> Process only looks at the virtual address

#### Example
- C-Language
```c
void func() {
    int x;
    ...
    x = x + 3; //this is the line of code we are interested in
}
```
- **Load** a value from memory
- **Increment** it by three
- **Store** the value back into memory

- Assembly
```
128 : movl 0x0 (%ebx), %eax ; load 0+ebx into eax
132 : addl $0x03, %eax ; add 3 to eax register
135 : movl %eax, 0x0 (%ebx) ; store eax back to mem
```
- Presume that the address of 'x' has been place in ebx register
- **Load** the value at that address in eax register
- **Add** 3 to eax register
- **Store** the value in eax back into memory

1. Fetch instruction at address 128
2. Execute this instruction (load from address 15KB)
3. Fetch instruction at address 132
4. Execute this instruction (no memory reference)
5. Fetch the instruction at address 135
6. Execute this instruction (store to address 15KB)

### Relocation Address Space
- The OS wants to place the process **somewhere else** in physical memory, not at address 0
    - The address space start at address 0



### Base and Bounds Register
- Base Register
    - The actual starting address of the process
    - Stores the top most address

- Bound Register
    - stores the bottom most address

```
- Stored at the bottom most of the stack
- If a process attempts to read memory from beyond the bound register, CPU will kill process
```


```
Important
```
- The OS sets the base and bound register when preparing a process
- the OS also changes the base and bound registers for the CPU

- PCB stores the base and bound registers

- When process terminates, all these process address spaces must be freed by the OS

### Dynamic (Hardware base) Relocation
- When a program starts running, the OS decides **where** in physical memory a process should be **loaded**
    - Set the base register a value
    > physical address = virtual address + base
    - Every virtual address must **not be greater than bound** and **negative**
    > $0 \leq$ virtual address < bounds

### Relocation and Address Translation
- 128 : movl 0x0 (%ebx), %eax

- **Fetch** instruction at address 128
> 32896 = 128 + 32KB (base)

- **Execute** this instruction
    - Load from address 15KB
    > 47KB = 15KB + 32KB (base)

#### Two ways of Bounds Register
- the size of address space
    - Bounds: 16KB
- Physical address of the end of address space
    - bounds: 48KB

### OS Issues for Memory Virtualizing
- The OS must `take action` to implement **base-and-bounds** approach
- Three critical junctures:
    - When a process **starts running**:
        - Finding space for address space in physical memory
    - When a process is **terminated**:
        - Reclaiming the memory for use
    - When context **switch occurs**:
        - Saving and storing the base-and-bounds pair

#### When a process starts running
- The OS must **find a room** for a new address space
    - free list: a list of the range of the phtsical memory which are not in use
    - The OS looks up the free list

#### When a process is terminated
- The OS must **put the memory back** on the free list

#### When Context Switch Occurs
- OS must **save and restore** the base-and-bounds pair
    - In **process structure** or **process control block (PCB)**