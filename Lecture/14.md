# Semaphores, Advanced Locks, and Synchronization Problems
## Semaphore Definition
- An object **with an integer value**
    - We can manipulate with two routines; `sem_wait()` and `sem_post()`
    - Initialization
    ```c
    #include <semaphore.h>
    sem_t s;
    sem_init(&s, 0, 1);
    ```
    - Declare a semaphore **s** and initialize it to the value 1
    - The second argument, 0, indicates that the semaphore is <u>shared</u> between *threads in the same process*

## Semaphore Interfaces
### `sem_wait()`
```c
int sem_wait(sem_t *s) {
    // decrement the value of semaphore s by one
    // wait if value of semaphore s is negative
}
```
- If the value of the semaphore was *one* or *higher* when called `sem_wait()`, **return right away**
- It will cause the caller to <u>suspend execution</u> waiting for a subsequent post
- When negative, the value of the semaphore is equal to the number of waiting threads

### `sem_post()`
```c
int sem_post(sem_t *s) {
    // increment the value of semaphore s by one
    // if there are one or more threads waiting, wake one
}
```
- Simply **increments** the value of the semaphore
- If there is a thread waiting to be woken, **wakes** one of them up

## Binary Semaphores (Locks)
- What should **x** be?
    - The initial value should be **1**
    ```c
    sem_t m;
    sem_init(&m, 0, X); // initialize semaphore to X; what should X be?
    // X = 1 for binary semaphore

    sem_wait(&m);
    // critical section here
    sem_post(&m);
    ```

## Semaphores As Condition Variables
```c
sem_t s;

void *
child(void *arg) {
    printf("child\n");
    sem_post(&s); // signal here: child is done
    return NULL;
}

int
main(int argc, char *argv[]) {
    sem_init(&s, 0, X); // What should X be?
    printf("parent: begin\n");
    pthread_t c;
    pthread_create(c, NULL, child, NULL);
    sem_wait(&s); // wait here for child
    printf("parent: end\n");
    return 0;
}


// parent: begin
// child
// parent: end
```
- What should x be?
    - The value of semaphore should be set to 0

### Parent Waiting For Child (Case 1)
- The parent call `sem_wait()` before the child has called `sem_post()`

### Parent Waiting For Child (Case 2)
- The child runs to completion before the parent call `sem_wait()`

## The Producer/Consumer (Bounded-Buffer) Problem
- **Producer**: `put()` interface
    - Wait for a buffer to become *empty* in order to put data into it
- **Consumer**: `get()` interface
    - Wait for a buffer to become `filled` before using it

```c
int buffer[MAX];
int fill = 0;
int use = 0;

void put(int value) {
    buffer[fill] = value; // line f1
    fill = (fill + 1) % MAX; // line f2
}

int get() {
    int tmp = buffer[use]; // line g1
    use = (use + 1) % MAX; // line g2
    return tmp;
}

sem_t empty; // initial value = MAX
sem_t full; // initial value = 0

void *producer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        sem_wait(&empty);  // line p1
        put(i); // line p2
        sem_post(&full);  // line p3
    }
}

void *consumer(void *arg) {
    int i, tmp = 0;
    while(tmp != -1) {
        sem_wait(&full); // line c1
        tmp = get(); // line c2
        sem_post(&empty); // line c3
        printf("%d\n", tmp);
    }
}

int main(int argc, char *argv[]) {
    //..
    sem_init(&empty, 0, MAX); // MAX buffers are empty to begin with
    sem_init(&full, 0, 0); // .. and 0 are full
    //...
}
```
- Imagine that `MAX` is greater than 1
    - If there are multiple producers, **race condition** can happen at line p1
    - It means that the old data may be overwritten
- We've forgotten **mutual exclusion**
    - Filling of a buffer and incrementing of the index into the buffer is in a **critical section**

## Adding Mutual Exclusion
- Incorrect mutual exclusion
```c
sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        sem_wait(&mutex); // line p0 (NEW LINE)
        sem_wait(&empty);  // line p1
        put(i); // line p2
        sem_post(&full);  // line p3
        sem_post(&mutex); // line p4 (NEW LINE)
    }
}

void *consumer(void *arg) {
    int i, tmp = 0;
    for(i = 0; i < loops; i++) {
        sem_wait(&mutex); // line c0 (NEW LINE)
        sem_wait(&full); // line c1
        tmp = get(); // line c2
        sem_post(&empty); // line c3
        sem_post(&mutex); // line c4 (NEW LINE)
        printf("%d\n", tmp);
    }
}
```
- Imagine two thread: one producer and one consumer
    - The consumer **acquire** the `mutex` (line c0)
    - The consumer **calls** `sem_wait()` on the full semaphore (line c1)
    - The consumer is **blocked** and **yields** the CPU
        - The consumer still holds the mutex!
    - The producer **calls** `sem_wait()` on the binary `mutex` semaphore (line p0)
    - The producer is now **stuck** waiting too
    - This is a classic deadlock situation

### Working Solution
```c
sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        sem_wait(&empty);  // line p1
         sem_wait(&mutex); // line p1.5 (MUTEX MOVED HERE)
        put(i); // line p2
        sem_post(&mutex); // line p2.5 (MUTEX MOVED HERE)
        sem_post(&full);  // line p3
    }
}

void *consumer(void *arg) {
    int i, tmp = 0;
    for(i = 0; i < loops; i++) {
        sem_wait(&full); // line c1
        sem_wait(&mutex); // line c1.5 (MUTEX MOVED HERE)
        tmp = get(); // line c2
        sem_post(&mutex); // line c2.5 (MUTEX MOVED HERE)
        sem_post(&empty); // line c3
        printf("%d\n", tmp);
    }
}
```

## Reader-Writer Locks
- Imagine a number of concurrent list operations, including **inserts** and simple **lookups**
    - insert:
        - Change the state of the list
        - A traditional <u>critical section</u> makes sense
    - lookup:
        - Simply *read* the data structure
        - As long as we can guarantee that no insert is on-going, we can allow many lookups to proceed **concurrently**
    > This special type of lock is known as the **reader-write lock**

- Only a **single writer** can acquire the lock
- Once a reader has acquired **a read lock**,
    - **More reader** will be allowed to acquire the read lock too
    - A writer will <u> have to wait</u> until all readers are finished

```c
typedef struct __rwlock_y {
    sem_t lock; // binary semaphore (basic lock)
    sem_t writelock; // used to allow ONE writer or MANY readers
    int readers; // count of readers reading in critical section
} rwlock_t;

void rwlock_init(rwlock_t *rw) {
    rw->readers = 0;
    sem_init(&rw->lock, 0, 1);
    sem_init(&rw->writelock, 0, 1);
}

void rwlock_acquire_readlock(rwlock_t *rw) {
    sem_wait(&rw->lock);
    rw->readers++;
    if(rw->readers == 1)
        sem_wait(&rw->writelock);   // first reader acquires writelock
    sem_post(&rw->lock);
}

void rwlock_release_readlock(rwlock_t *rw) {
    sem_wait(&rw->lock);
    rw->readers--;
    if(rw->readers == 0)
        sem_post(&rw->writelock); //last reader releases writelock
    sem_post(&rw->lock);
}

void rwlock_acquire_writelock(rwlock_t *rw) {
    sem_wait(&rw->writelock);
}

void rwlock_release_writelock(rwlock_t *rw) {
    sem_post(&rw->writelock);
}
```

- The reader-write locks have **fairness problem**
    - It would be relatively easy for reader to **starve writer**
    - How to <u>prevent</u> more readers from entering the lock once a writer is waiting?

> Possible finals exam
- How to fix this fairness problem?
    - Have a switch variable to check whether the writer is waiting or not
    - If the reader sees that the writer is waiting, the readers won't enter the critical section


## The Dining Philosophers
- Assume there are five "**philosophers**" sitting around a table
    - Between each pair of philosophers is <u>a single fork</u> (five total)
    - The philosophers each have times where they **think**, and don't need any forks, and times where they **eat**
    - In order to *eat*, a philosopher needs **two forks**, both the one on their *left* and the one on their *right*
    - **The contention for these forks**
### Key Challenge
    - There is **no deadlock**
    - **No** philosopher **starves** and never gets to eat
    - **Concurrency** is high

- Basic loop of each philosopher
    ```c
    while(1) {
        think();
        getforks();
        eat();
        putforks();
    }
    ```
- Helper functions (Downey's solutions)
    ```c
    // helper functions
    int left(int p) { return p; }
    
    int right(int p) {
        return (p + 1) % 5;
    }
    ```
- Philosopher p wishes to refer to the fork on their left -> call `left(p)`
- Philosopher p wishes to refer to the fork on their right -> call `right(p)`
### Broken solution
- We need some **semaphore**, one for each fork: `sem_t forks[5]`
    ```c
    void get_forks() {
        sem_wait(forks[left(p)]);
        sem_wait(forks[right(p)]);
    }

    void put_forks() {
        sem_post(forks[left(p)]);
        sem_post(forks[right(p)]);
    }
    ```
- **Deadlock** occur!
    - If each philosopher happens to **grab the fork on their left** before any philosopher can grab the fork on their right
    - Each will be stuck *holding one fork* and waiting for another, *forever*

### A solution: Breaking The Dependency
- Change **how forks are acquired**
    - Let's assume that philosopher 4 acquire the forks in a *different order*
    ```c
    void getforks() {
        if(p == 4) {
            sem_wait(forks[right(p)]);
            sem_wait(forks[left(p)]);
        }
        else {
            sem_wait(forks[left(p)]);
            sem_wait(forks[right(p)]);
        }
    }
    ```
    - there is no situation where each philosopher grabs one fork and is stuck waiting for another
    - **The cycle of waiting is broken**

## How to Implement Semaphores
- Build our own version of semaphores called **Zemaphores**

```c
typedef struct __Zem_t {
    int value;
    pthread_cond_t cond;
    pthread_mutex_t lock;
} Zem_t;

// only one thread can call this
void Zem_init (Zem_t *s, int value) {
    s->value = value;
    Cond_init(&s->cond);
    Mutex_init(&s->lock);
}

void Zem_wait(Zem_t *s) {
    Mutex_lock(&s->lock);
    while(s->value <= 0)
        Cond_wait(&s->cond, &s->lock);
    s->value--;
    Mutex_unlock(&s->lock);
}

void Zem_post(Zem_t *s) {
    Mutex_lock(&s->lock);
    s->value++;
    Cond_signal(&s->cond);
    Mutex_unlock(&s->lock);
}
```
- Zemaphores don't maintain the invariant that the value of the semaphore reflects the number of waiting threads
    - The value never be lower than zero
    - This behavior is **easier** to implement and **matches** the current Linux implementation