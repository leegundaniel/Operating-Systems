# Semaphores, Advanced Locks, and Synchronization Problems
## Semaphore Definition
- An object **with an integer value**
    - We can manipulate with two routines; `sem_wait()` and `sem_post()`
    - Initialization
    ```c
    #include <semaphore.h>
    sem_t s;
    sem_init(&s, 0, 1);
    ```
    - Declare a semaphore **s** and initialize it to the value 1
    - The second argument, 0, indicates that the semaphore is <u>shared</u> between *threads in the same process*

## Semaphore Interfaces
### `sem_wait()`
```c
int sem_wait(sem_t *s) {
    // decrement the value of semaphore s by one
    // wait if value of semaphore s is negative
}
```
- If the value of the semaphore was *one* or *higher* when called `sem_wait()`, **return right away**
- It will cause the caller to <u>suspend execution</u> waiting for a subsequent post
- When negative, the value of the semaphore is equal to the number of waiting threads

### `sem_post()`
```c
int sem_post(sem_t *s) {
    // increment the value of semaphore s by one
    // if there are one or more threads waiting, wake one
}
```
- Simply **increments** the value of the semaphore
- If there is a thread waiting to be woken, **wakes** one of them up

## Binary Semaphores (Locks)
- What should **x** be?
    - The initial value should be **1**
    ```c
    sem_t m;
    sem_init(&m, 0, X); // initialize semaphore to X; what should X be?
    // X = 1 for binary semaphore

    sem_wait(&m);
    // critical section here
    sem_post(&m);
    ```

## Semaphores As Condition Variables
```c
sem_t s;

void *
child(void *arg) {
    printf("child\n");
    sem_post(&s); // signal here: child is done
    return NULL;
}

int
main(int argc, char *argv[]) {
    sem_init(&s, 0, X); // What should X be?
    printf("parent: begin\n");
    pthread_t c;
    pthread_create(c, NULL, child, NULL);
    sem_wait(&s); // wait here for child
    printf("parent: end\n");
    return 0;
}


// parent: begin
// child
// parent: end
```
- What should x be?
    - The value of semaphore should be set to 0

### Parent Waiting For Child (Case 1)
- The parent call `sem_wait()` before the child has called `sem_post()`

### Parent Waiting For Child (Case 2)
- The child runs to completion before the parent call `sem_wait()`

## The Producer/Consumer (Bounded-Buffer) Problem
- **Producer**: `put()` interface
    - Wait for a buffer to become *empty* in order to put data into it
- **Consumer**: `get()` interface
    - Wait for a buffer to become `filled` before using it

```c
int buffer[MAX];
int fill = 0;
int use = 0;

void put(int value) {
    buffer[fill] = value; // line f1
    fill = (fill + 1) % MAX; // line f2
}

int get() {
    int tmp = buffer[use]; // line g1
    use = (use + 1) % MAX; // line g2
    return tmp;
}

sem_t empty; // initial value = MAX
sem_t full; // initial value = 0

void *producer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        sem_wait(&empty);  // line p1
        put(i); // line p2
        sem_post(&full);  // line p3
    }
}

void *consumer(void *arg) {
    int i, tmp = 0;
    while(tmp != -1) {
        sem_wait(&full); // line c1
        tmp = get(); // line c2
        sem_post(&empty); // line c3
        printf("%d\n", tmp);
    }
}

int main(int argc, char *argv[]) {
    //..
    sem_init(&empty, 0, MAX); // MAX buffers are empty to begin with
    sem_init(&full, 0, 0); // .. and 0 are full
    //...
}
```
- Imagine that `MAX` is greater than 1
    - If there are multiple producers, **race condition** can happen at line p1
    - It means that the old data may be overwritten
- We've forgotten **mutual exclusion**
    - Filling of a buffer and incrementing of the index into the buffer is in a **critical section**

## Adding Mutual Exclusion
- Incorrect mutual exclusion
```c
sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        sem_wait(&mutex); // line p0 (NEW LINE)
        sem_wait(&empty);  // line p1
        put(i); // line p2
        sem_post(&full);  // line p3
        sem_post(&mutex); // line p4 (NEW LINE)
    }
}

void *consumer(void *arg) {
    int i, tmp = 0;
    for(i = 0; i < loops; i++) {
        sem_wait(&mutex); // line c0 (NEW LINE)
        sem_wait(&full); // line c1
        tmp = get(); // line c2
        sem_post(&empty); // line c3
        sem_post(&mutex); // line c4 (NEW LINE)
        printf("%d\n", tmp);
    }
}
```
- Imagine two thread: one producer and one consumer
    - The consumer **acquire** the `mutex` (line c0)
    - The consumer **calls** `sem_wait()` on the full semaphore (line c1)
    - The consumer is **blocked** and **yields** the CPU
        - The consumer still holds the mutex!
    - The producer **calls** `sem_wait()` on the binary `mutex` semaphore (line p0)
    - The producer is now **stuck** waiting too
    - This is a classic deadlock situation

### Working Solution
```c
sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        sem_wait(&empty);  // line p1
         sem_wait(&mutex); // line p1.5 (MUTEX MOVED HERE)
        put(i); // line p2
        sem_post(&mutex); // line p2.5 (MUTEX MOVED HERE)
        sem_post(&full);  // line p3
    }
}

void *consumer(void *arg) {
    int i, tmp = 0;
    for(i = 0; i < loops; i++) {
        sem_wait(&full); // line c1
        sem_wait(&mutex); // line c1.5 (MUTEX MOVED HERE)
        tmp = get(); // line c2
        sem_post(&mutex); // line c2.5 (MUTEX MOVED HERE)
        sem_post(&empty); // line c3
        printf("%d\n", tmp);
    }
}
```

## Reader-Writer Locks
- Imagine a number of concurrent list operations, including **inserts** and simple **lookups**
    - insert:
        - Change the state of the list
        - A traditional <u>critical section</u> makes sense
    - lookup:
        - Simply *read* the data structure
        - As long as we can guarantee that no insert is on-going, we can allow many lookups to proceed **concurrently**
    > This special type of lock is known as the **reader-write lock**

- Only a **single writer** can acquire the lock
- Once a reader has acquired **a read lock**,
    - **More reader** will be allowed to acquire the read lock too
    - A writer will <u> have to wait</u> until all readers are finished

```c
typedef struct __rwlock_y {
    sem_t lock; // binary semaphore (basic lock)
    sem_t writelock; // used to allow ONE writer or MANY readers
    int readers; // count of readers reading in critical section
} rwlock_t;

void rwlock_init(rwlock_t *rw) {
    
}