# Paging Schemes
- An approach to tackle the one of the two problems of paging
    - Page table takes up too much of the memory

## Paging: Linear Tables
- We usually have one page table for every process in the system
    - Assume that 32-bit address space with 4KB pages and 4-byte page-table entry

$$\text{Page table size} = \frac{2^{32}}{2^{12}} * 4\text{Byte} = 4M \text{Byte}$$

> Page table are too big and thus consume too much memory

## Paging: Smaller Tables
- Page table are too big and thus consume too much memory
    - Assume that 32-bit address space with 64KB pages and 4-byte page-table entry

$$\frac{2^{32}}{2^{16}} * 4\text{Byte} = 256 \text{KB per page table}$$

> Big pages lead to **internal fragmentation**

## Problem
- Single page table for the entries address space of process
- Most of the page table is **unused** full of invalid entries

## Hybrid Approach: Paging and Segments
- Segmented Paging
- In order to reduce the memory overhead of page tables
    - Using base not to point to the segment itself but rather to hold the `physical address of the page table` of that segment
    - The bounds register is used to indicate the end of the page table

### Simple Example of Hybrid Approach
- Each process has **three** page tables associated with it
    - When process is running, the base register for each of these segments contains the physical address of a linear page table for that segment

### TLB miss on Hybrid Approach
- The hardware get to **physical address** from **page table**
    - The hardware uses the segment bits(SN) to determine which base and bounds pair to use
    - The hardware then takes the **physical address** therein and **combines** it with the VPN as follows to form the address of the page table entry(PTE)

```
SN = (VirtualAddress & SEG_MASK) >> SN_SHIFT
VPN = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
```

### Problem of Hybrid Approach
- Hybrid Approach is not without problems
    - If we have a large but sparsely-used heap, we can still end up with a lot of page table waste
    - Causing external fragmentation to arise again

## Multi-Level Page Tables
- Turns the linear page table into something like a tree
    - Chop up the page table into page-sized units
    - If an entire page of page-table entries is invalid, don't allocate that page of the page table at all
    - To track whether a page of the page table is valid, use a new structure, called `page directory`

- PBTR will point to the page directory (4KB)
- Page directory will contain page table entries for the code, heap, and stack (each 4KB)
- requiring a total of 16KB

### Multi-Level Page Tables: Page Directory Entries
- Page directory contains one entry per page of the page table
    - it consists of a number of `page directory entries (PDE)`
    - PDE has a valid bit and page frame number (PFN)

### Multi-Level Page Tables: Advantages & Disadvantages
- Advantage
    - Only allocates page-table space in proportion to the amount of address space you are using
    - The OS can grab the next free page when it needs to allocate or grow a page table
- Disadvantage
    - Multi-level table is a small example of a `time-space trade-off`
        - Time efficient, space inefficient, vice versa
        - 3 times the memory access (original paging is 2 times)
    - `Complexity`

### Multi-Level Page Table: Level of Indirection
- A multi-level structure can adjust `level of indirection` through use of the page directory
    - Indirection place page-table pages wherever we would like in physical memory

#### A Detailed Multi-Level Example: Page Directory Idx
- For better understanding of the idea behind multi-level page tables, let's study an example
    - 16KB address space with 64-byte pages
        - 6bit offset, 8bit VPN

- The page directory needs one entry per page of the page table
    - it has 16 entries
        - 4bits required (bits 6 - 9)
        - The remaining bits becomes the page directory index (bits 10 - 13)
- The page-directory entry is invalid -> Raise an exception (The access is invalid)

- The PDE is valid, we have more work to do
    - To fetch the page table entry(PTE) from the page of the page table pointed to by this page-directory entry
- This `page-table index` can then be used to indedx into the page table itself

### More than two Level
- In some cases, a deeper tree is possible

#### Page Table Index
- VPN: 30 - 9
    - Page Directory Index: 30 - 16
    - Page Table Index: 16 - 9
- offset: 9 - 0

#### Page Directory
- If our page directory has $2^{14}$ entries, it spans not one page but 128
- To remedy this problem, we build a `further level` of the tree, by splitting the page directory itself into multiple pages of the page directory

- VPN: 30 - 9
    - PD index 0: 30 - 23
    - PD index 1: 23 - 16
    - Page Table Index: 16 - 9
- Offset: 9 - 0

> PD index 1: Page Middle Directory (PMD)

### Multi-Level Page Table Control Flow
```c
VPN = (VirtualAddress & VPN_Mask) >> SHIFT
(Success, TlbEntry) = TLB_Lookup(VPN)
    if(Success == True) { //TLB Hit
        if(CanAccess(TlbEntry.ProtectBit) == True) {
            Offset = VirtualAddress & OFFSET_MASK
            PhysAddr = (TlbEntry.PFN << SHIFT) | Offset
            AccessMemory(PhysAddr)
        } 
        else RaiseException (PROTECTION_ERROR)
    } 
    else { // perform the full multi-level loopup
        PDIndex = (VPN & PD_MASK) >> PD_SHIFT
        PDEAddr = PDBR + (PDIndex * sizeof(PDE))
        PDE = AccessMemory(PDEAddr)
        if(PDE.Valid == False)
            RaiseException(SEGMENTATION_FAULT)
        else // PDE is Valid: now fetch PTE from PT
            PTIndex = (VPN & PT_MASK) >> PT_SHIFT
            PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))
            PTE = AccessMemory(PTEAddr)
            if(PTE.Valid == False)
                RaiseException(SEGMENTATION_FAULT)
            else if(CanAccess(PTE.ProtectBits) == False)
                RaiseException(PROTECTION_FAULT)
            else
                TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)
                RetryInstruction()

```
- line 1: extract the virtual page number (VPN)
- line 2: check if the TLB holds the translation for this VPN
- Lines 5 - 8: extract the page frame number from the relevant TLB entry, and form the desired physical address and access memory
- Line 12: extract the Page Directory Index
- Line 13: get Page Directory Entry (PDE)
- Lines 15 - 17: Check PDE valid flag
    - if valid flag is true
        - fetch Page Table Entry from Page Table

## Inverted Page Tables (IPT)
- Keeping a single page table that has an entry for each <u>physical page</u> of the system
- The entry tells us which process is using this page, and which virtual page of that process maps to this physical page
- Used by cheap or simpler systems
    - Linear search required, but used for devices with small page size