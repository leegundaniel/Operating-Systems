# Locality and Caching
- An approach to tackle the one of the two problems of paging
    - twice the amount of memory access due to page table address
        - for address translation

## TLB (Translation Look-Aside Buffer)
- Part of the chip's memory-management unit (MMU)
- A hardware cache of **popular** virtual-to-physical address translation
    - a cache to page table entry
1. the CPU gives a logical address to the MMU
2. MMU checks TLB for the address
    - if TLB hit, physical address
    - if TLB miss, check page entries

- Fast, expensive, and small memory size
    - usually doesn't exceed 256 entries, each entry is 4KB

### TLB Basic Algorithms
```c
VPN = (VirtualAddress & VPN_Mask) >> SHIFT
(Success, TlbEntry) = TLB_Lookup(VPN)
    if(Success == True) { //TLB Hit
        if(CanAccess(TlbEntry.ProtectBit) == True) {
            Offset = VirtualAddress & OFFSET_MASK
            PhysAddr = (TlbEntry.PFN << SHIFT) | Offset
            AccessMemory(PhysAddr)
        } 
        else RaiseException (PROTECTION_ERROR)
    } 
    else { // TLB Miss
        PTE Addr = PTBR + (VPN * sizeof(PTE))
        PTE = AccessMemory(PTEAddr)
        (...)
    }
    else {
        TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)
        RetryInstruction()
    }        
```
- line 1: extract the virtual page number (VPN)
- line 2: check if the TLB holds the translation for this VPN
- lines 5-8: extract the page frame number from the relevant TLB entry, and form the desired physical address and access memory
- lines 11-12: The hardware accesses the page table to find the translation
- line 16: update the TLB with the translation

### Example: Accessing An Array
- How a TLB can improve its performance
- The TLB improves performance due to `spatial locality`
```c
int sum = 0;
for(i = 0; i < 10; i++) {
    sum += a[i];
}
```
- If TLB is 16bytes
- This code runs through 3 VPNs
- TLB hit ratio for code (array with 10 entries)
    - 3 misses due to 3 VPNs
    - 7 hits since rest are spatially in same VPNs
    - thus TLB hit rate is 70%

- However, actual TLB entry is 4KB, which is 1000 integer values

## Locality
> IMPORTANT
- Temporal Locality
    - An instruction or data item that has been recently accessed will likely be re-accessed soon in the future
    - First access is page1, 2nd access also probably page1
- Spatial Locality
    - If a program accesses memory at address x, it will likely soon access memory near x
    - First access is page 1, 2nd access in near by page1

## Who handles the TLB Miss?
- Hardware handle the TLB miss entirely on **CISC**
    - the hardware has to know exactly where the page tables are located in memory
    - The hardware would "walk" the page table, find the correct page-table entry and `extract` the desired translation, `update` and `retry` instruction
    - **<u>hardware-managed TLB</u>**
    - So the OS doesn't have to care about the TLB miss or its functionality

- **RISC** have what is known as a **<u>software-managed TLB</u>**
    - On a TLB miss, the hardware raises exception (trap handler)
        - Trap handler is code within the OS that is written with the express purpose of `handling TLB miss`

### TLB Control Flow Algorithm (OS Handled)
```c
VPN = (VirtualAddress & VPN_Mask) >> SHIFT
(Success, TlbEntry) = TLB_Lookup(VPN)
    if(Success == True) { //TLB Hit
        if(CanAccess(TlbEntry.ProtectBit) == True) {
            Offset = VirtualAddress & OFFSET_MASK
            PhysAddr = (TlbEntry.PFN << SHIFT) | Offset
            AccessMemory(PhysAddr)
        } 
        else RaiseException (
        PROTECTION_ERROR)
    } 
    else { // TLB Miss
        RaiseException(TLB_MISS)
        // no need to have code for TLB Miss except raising exception
        // since the OS will handle the exception
    }
```

## TLB Entry
- TLB is managed by **Fully-Associative** method
    - A typical TLB might have 32, 64, or 128 entries
    - Hardware search the entire TLB in parallel to find the desired translation
    - Other bits: valid bits, protection bits, address-space identifier, dirty bit
> VPN - PFN - other bits

### TLB Issue: Context Switching
- Each process has their own virtual address space / their own page table

1. a process stores their VPN into the TLB
2. Context switching occurs to another process and it stores the same VPN value into the TLB
3. Same VPN value will exist within TLB Table
> Can't Distinguish which entry is meant for which process

- Solution:
    - Provide an address space identifier (ASID) field in the TLB
        - Assigns a number for each process

- Before ASID existed, once context switch occurs, flush the TLB
    - Clean TLB, Clean mind
        - Don't think about it
    - Problem:
        - Must fill TLB Table again
            - Cold Miss (Several misses occur)
            - sudden spike of TLB misses

### Another Case
- Two processes **share a page**
    - Process 1 is sharing physical page 101 with Process 2
    - P1 maps this page into the 10th page of its address space
    - P2 maps this page to the 50th page of its address space
    > Sharing of pages is useful as it reduces the number of physical pages in use

## RLB Replacement Policy
- LRU (Least Recently Used)
    - Evict an entry that has not recently been used
    - Take advantage of *locality* in the memory-reference stream
- check [PDF](08-Locality%20and%20Caching.pdf) for example

## A Real TLB Entry
- All 64 bits of this TLB entry(Example of MIPS R4000)
    - 19-bit VPN
    - 24-bit PFN
    - Global bit(G): pages globally-shared among processes
    - ASID: OS usage to distinguish between address spaces
    - Coherence bit(C): determine how a page is cached by the hardware
    - Dirty bit(D): If page has been written
    - Valid Bit(V): Tell hardware if there is valid translation present in entry