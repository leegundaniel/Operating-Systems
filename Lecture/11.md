# Concurrency, Concepts and Case Studies
## Thread
- A new abstraction for <u>a single running process</u>
- Multi-threaded program
    - A multi-threaded program has more than one point of execution
    - Multiple PCs (Program Counter)
    - They `share` the same `address space`

### Context switch betweem threads
- Each thread has its own <u>program counter</u> and <u>set of registers</u>
    - One or more **thread control blocks (TCBs)** are needed to store the state of each thread
- When switching from running one (T1) to running the other (T2)
    - The register state of T1 be saved.
    - The register state of T2 restored.
    - The `address space remains` the same.

### The stack of the relevant thread
- There will be `one stack per thread`

### Race condition
- Example with two threads
    - counter = counter + 1 (default is 50)
    - We expect the result to be 52. However, both store 51 and restore 51. Answer will become 51
- Two or more threads access the same variable at the same time

### Critical section
- A piece of code that `accesses a shared variable` and must not be concurrently executed by more than one thread
    - Multiple thread executing critical section can result in a race condition
    - Need to support **atomicity** for critical sections (**mutual exclusion**)

### Locks
- Ensure that any such critical section executes as if it were a single atomic instruction (**execute a series of instructions atomically**)
```c
lock_t mutex;

lock(&mutex);
balance = balance + 1; // critical section
unlock(&mutex);
```

## Thread Creation
- How to create and control threads
```c
#include <pthread.h>

int
pthread_create (    pthread_t*  thread,
              const pthread_t*  attr,
                    void*       (*start_routine)(void*),
                    void*       arg);
```

- thread: Used to interact with this thread
- attr: Used to specify any attributes this thread might have
    - Stack size, Scheduling priority, ...
- start_routine: the function this thread start running in
- arg: the argument to be passed to the function (*start routine*)
    - a void pointer allows us to pass in *any type of* argument

- If *start_routine* instead required another type argument, the declaration would look like this:
    - An integer argument:
    ```c
    int pthread_create(..., // first two args are the same
                        void* (*start_routine) (int),
                        int arg);
    ```
    - Return an integer:
    ```c
    int pthread_create(... // first two args are the same
                        int (*start_routine)(void*),
                        void* arg);
    ```

### Example: Creating a Thread
```c
#include <pthread.h>

typedef struct __myarg_t {
    int a;
    int b;
} myarg_t;

void *mythread(void *args) {
    myarg_t *m = (myarg_t *) arg;
    printf("%d %d\n", m->a, m->b);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    int rc;

    myarg_t args;
    args.a = 10;
    args.b = 20;
    rc = pthread_create(&p, NULL, mythread, &args);
    ...
}
```

## Wait for a thread to complete
```c
int pthread_join(pthread_t thread, void **value_ptr);
```
- thread: Specify which thread *to wait for*
- value_ptr: a pointer to the <u>return value</u>
    - Because pthread_join() routine changes the value, you need to `pass in a pointer` to that value

### Example
```c
int main(int argc, char *argv[]) {
    int rc;
    pthread_t p;
    myret_t *m;

    myarg_t args;
    args.a = 10;
    args.b = 20;
    pthread_create(&p, NULL, mythread, &args);
    pthread_join(p, (void **) &m);  //this thread has been
    //waiting inside of the
    // pthread_join() routine
    printf("returned %d %d\n", m->x, m->y);
    return 0;
}
```

### Example: Dangeround code
- Be careful with <u>how values are returned</u> from a thread
```c
void *mythread(void *arg) {
    myarg_t *m = (myarg_t *) arg;
    printf("%d %d\n", m->a, m->b);
    myret_t r; // ALLOCATED ON STACK: BAD!
    r.x = 1;
    r.y = 2;
    return (void *) &r;   
}
```
- When the variable r returns, it is automatically `de-allocated`

### Example:
- Just passing in a single value
```c
    void *mythread (void *arg) {
        int m = (int) arg;
        printf("%d\n", m);
        return (void *) (arg + 1);
    }

    int main (int argc, char  *argv[]) {
        pthread_t p;
        int rc, m;
        pthread_create(&p, NULL, mythread, (void *) 100);
        pthread_join(p, (void **) &m);
        printf("returned %d\n", m);
        return 0;
    }
```