# Concurrency, Concepts and Case Studies
## Thread
- A new abstraction for <u>a single running process</u>
- Multi-threaded program
    - A multi-threaded program has more than one point of execution
    - Multiple PCs (Program Counter)
    - They `share` the same `address space`

### Context switch betweem threads
- Each thread has its own <u>program counter</u> and <u>set of registers</u>
    - One or more **thread control blocks (TCBs)** are needed to store the state of each thread
- When switching from running one (T1) to running the other (T2)
    - The register state of T1 be saved.
    - The register state of T2 restored.
    - The `address space remains` the same.

### The stack of the relevant thread
- There will be `one stack per thread`

### Race condition
- Example with two threads
    - counter = counter + 1 (default is 50)
    - We expect the result to be 52. However, both store 51 and restore 51. Answer will become 51
- Two or more threads access the same variable at the same time

### Critical section
- A piece of code that `accesses a shared variable` and must not be concurrently executed by more than one thread
    - Multiple thread executing critical section can result in a race condition
    - Need to support **atomicity** for critical sections (**mutual exclusion**)

### Locks
- Ensure that any such critical section executes as if it were a single atomic instruction (**execute a series of instructions atomically**)
```c
lock_t mutex;

lock(&mutex);
balance = balance + 1; // critical section
unlock(&mutex);
```

## Thread Creation
- How to create and control threads
```c
#include <pthread.h>

int
pthread_create (    pthread_t*  thread,
              const pthread_t*  attr,
                    void*       (*start_routine)(void*),
                    void*       arg);
```

- thread: Used to interact with this thread
- attr: Used to specify any attributes this thread might have
    - Stack size, Scheduling priority, ...
- start_routine: the function this thread start running in
- arg: the argument to be passed to the function (*start routine*)
    - a void pointer allows us to pass in *any type of* argument

- If *start_routine* instead required another type argument, the declaration would look like this:
    - An integer argument:
    ```c
    int pthread_create(..., // first two args are the same
                        void* (*start_routine) (int),
                        int arg);
    ```
    - Return an integer:
    ```c
    int pthread_create(... // first two args are the same
                        int (*start_routine)(void*),
                        void* arg);
    ```

### Example: Creating a Thread
```c
#include <pthread.h>

typedef struct __myarg_t {
    int a;
    int b;
} myarg_t;

void *mythread(void *args) {
    myarg_t *m = (myarg_t *) arg;
    printf("%d %d\n", m->a, m->b);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    int rc;

    myarg_t args;
    args.a = 10;
    args.b = 20;
    rc = pthread_create(&p, NULL, mythread, &args);
    ...
}
```

## Wait for a thread to complete
```c
int pthread_join(pthread_t thread, void **value_ptr);
```
- thread: Specify which thread *to wait for*
- value_ptr: a pointer to the <u>return value</u>
    - Because pthread_join() routine changes the value, you need to `pass in a pointer` to that value

### Example
```c
int main(int argc, char *argv[]) {
    int rc;
    pthread_t p;
    myret_t *m;

    myarg_t args;
    args.a = 10;
    args.b = 20;
    pthread_create(&p, NULL, mythread, &args);
    pthread_join(p, (void **) &m);  //this thread has been
    //waiting inside of the
    // pthread_join() routine
    printf("returned %d %d\n", m->x, m->y);
    return 0;
}
```

### Example: Dangerous code
- Be careful with <u>how values are returned</u> from a thread
```c
void *mythread(void *arg) {
    myarg_t *m = (myarg_t *) arg;
    printf("%d %d\n", m->a, m->b);
    myret_t r; // ALLOCATED ON STACK: BAD!
    r.x = 1;
    r.y = 2;
    return (void *) &r;   
}
```
- When the variable r returns, it is automatically `de-allocated`

### Example: Single Argument Passing to a Thread
- Just passing in a single value
```c
    void *mythread (void *arg) {
        int m = (int) arg;
        printf("%d\n", m);
        return (void *) (arg + 1);
    }

    int main (int argc, char  *argv[]) {
        pthread_t p;
        int rc, m;
        pthread_create(&p, NULL, mythread, (void *) 100);
        pthread_join(p, (void **) &m);
        printf("returned %d\n", m);
        return 0;
    }
```

## Locks
- Provide `mutual exclusion` to a critical section
    - Interface
        ```c
        int pthread_mutex_lock(pthread_mutex_t *mutex);
        int pthread_mutex_unlock (pthread_mutex_t *mutex);
        ```
    - Usage (w/o lock initialization and error check)
        ```c
        pthread_mutext_t lock;
        pthread_mutex_lock (&lock);
        x = x + 1; // or whatever your critical section is
        pthread_mutex_unlock(&lock);
        ```
        - no ther thread hold the lock -> the thread will acquire the lock and `enter the critical section`
        - If another thread holds the lock -> the thread will `not return from the call` until it has acquired the lock

- All locks must be `properly initialized`
    - On way: using `PTHREAD_MUTEX_INITIALIZER`
        ```c
        pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
        ```

    - The dynamic way: using `pthread_mutex_init()`
        ```c
        int rc = pthread_mutex_init(&lock, NULL);
        assert(rc == 0); // always check success!
        ```

- `Check error` code when calling lock and unlock
    - An example wrapper
        ```c
        // Use this to keep your code clean but check for failures
        // Only use if exiting program is OK upon failure
        void Pthread_mutex_lock(pthread_mutex_t *mutex) {
            int r = pthread_mutex_lock(mutex);
            assert(rc == 0);
        }
        ```
- These two calls are used in lock acquisition
    ```c
    int pthread_mutex_trylock(pthread_mutex_t *mutex);
    int pthread_mutex_timelock(pthread_mutex_t *mutex, 
                                struct timespec *abs_timeout);
    ```
    - trylock return failure if the lock is already held
    - timelock: return after a timeout

## Condition Variables
- **Condition variables** are useful when some kind of `signaling` must take place between threads
    ```c
    int pthread_cond_wait (pthread_cond_t *cond,
                            pthread_mutex_t *mutex);
    int pthread_cond_signal (pthread_cond_t *cond);
    ```
    - pthread_cond_wait:
        - put the calling thread to sleep
        - wait for some other thread to signal it
        > the thread calling pthread_cond_wait must be the currently holding the lock
    - pthread_cond_signal:
        - Unblock at least one of the threads that are blocked on the condition variable

- A thread calling wait routine:
    ```c
    pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t init = PTHREAD_COND_INITIALIZER;

    pthread_mutex_lock(&lock);
    while (initialized == 0)
        pthread_cond_wait(&init, &lock);
    pthread_mutex_unlock(&lock);
    ```
    - The wait call `releases the lock` when putting said caller to sleep
    - Before returning after being woken, the wait call `re-acquire the lock`
    - Used when reinitializing the device
- A thread calling signal routine:
    ```c
    pthread_mutex_lock(&lock);
    initialized = 1;
    pthread_cond_signal(&init);
    pthread_mutex_unlock(&lock);
    ```

- The waiting thread **re-checks** the condition `in a while loop`, instead of a simple if statement
    ```c
    pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t init = PTHREAD_COND_INITIALIZER;

    pthread_mutex_lock(&lock);
    while(initialized == 0)
        pthread_cond_wait(&init, &lock);
    pthread_mutex_unlock(&lock);
    ```
    - without rechecking, the waiting thread will continue thihnking that the condition has changed <u> even though it has not</u>

- Don't ever to this
    - A thread calling wait routine:
        ```c
        while(initialized == 0)
            ; // spin
        ```
    - A thread calling signal routine:
        ```c
        initialized = 1;
        ```
    - It performs poorly in many cases -> just wastes CPU cycles
    - It is error prone

## Compiling and Running
- To compile them, you must include the header `pthread.h`

    - Explicitly link with the `pthreads library`, by adding the `-pthread` flag
    ```c
    prompt > gcc -o main main.c -Wall -pthread
    ```
- For more information,
    ```c
    man -k pthread
    ```