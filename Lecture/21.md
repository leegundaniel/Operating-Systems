# File System Design
## The Way to Think
- There are two different aspects to implement file system
    - **Data structures**
        - What types of on-disk structures are utilized by the file system to organize its data and metadata?
    - **Access methods**
        - How does it map the calls made by a process as `open()`, `read()`, `write()`, etc.
        - Which structures are read during the execution of a particular system call?

## Overall Organization
- Let's develop the overall organization of the file system data structure
- Divide the disk into **blocks**
    - Block size is 4KB
    - The blocks are addressed from 0 to N-1

## Data Region in File System
- Reserve **data region** to store user data
    - File system has to track which data block comprise a file, the size of the file, its owner, etc

> How do we store these **inodes** in file system?

## Inode Table in File System
- Reserve some space for **inode table**
    - This holds an array of on-disk inodes
    - Ex) inodes tables: 3 ~ 7, inode size : 256 bytes
        - 4-KB block can hold 16 inodes
        - File system contains 80 inodes (maximum number of files)

## Allocation Structures
- This is to track whether inodes or data blocks are free or allocated
- Use **bitmap**, each bit indicates free(0) or in-use(1)
    - **Data bitmap: for data region
    - **inode bitmap**: for inode table

## Superblock
- Super block contains **information** about a **particular file system**
    - Ex: The number of inodes, begin location of inode table, etc.
    - Thus, when mounting a file system, OS will read the superblock first, to initialize various information

## File Organization: inode
- Each inode is referred to by inode number
    - With inode number, a file system calculates where the inode is on the disk
    - Ex: inode number: 32
        - Calculate the offset into the inode region
        - 32 x sizeof(inode) (256 bytes) = 8192
        - Add start address of the inode table (12KB) + inode region (8 KB) = 20KB
- Disks are not byte addressable, sector addressable
- Disk consist of a large number of addressable sectors (512 bytes)
    - Ex: Fetch the block of inode (inode number: 32)
    - Sector address `iaddr` of the inode block
    - `blk`: (inumber * sizeof(inode)) /blocksize
    - `sector`: ((blk * blocksize) + inodeStartAddr) / sectorsize
- `inode` have all of the information about a file
    - File type (regular file, directory, etc.)
    - Size, the number of blocks allocated to it
    - Protection information (who ones the file, who can access, etc.)
    - Time information
    - etc.

- EXT2 Inode

| Size | Name | What is this inode field for? |
| -- | -- | -- |
| 2 | mode | can this file be read/written/executed? |
| 2 | uid | owns this file? |
| 4 | size | how many bytes are in this file? |
| 4 | time | what time was this file last accessed? |
| 4 | ctime | what time was this file created? |
| 4 | mtime | what time was this file last modified? |
| 4 | dtime | what time was this inode deleted? |
| 4 | gid | which group does this file belong to? |
| 2 | links_count | how many hard links are there to this file? |
| 2 | blocks | how many blocks have been allocated to this file? |
| 4 | flags | how should ext2 use this inode? |
| 4 | osd1 | an OS-dependent field |
| 60 | block | a set of disk pointers (15 total) |
| 4 | generation | file version (used by NFS) |
| 4 | file_acl | a new permissions model beyond mode bits |
| 4 | dir_acl | called access control lists |
| 4 | faddr | an unsupported field |
| 12 | i_osd2 | another OS-dependent field |


## Multi-Level Index
- To support bigger files, we use multi-level index
- **Indirect pointer** points to a block that contains more pointers
    - inode have fixed number of direct pointers (12) and a single indirect pointer
    - If a file grows large enough, an indirect block is allocated, inode's slot for an indirect pointer is set to point to it
        - (12 + 1024) * 4K or 4144KB

- **Double indirect pointer** points to a block that countains indirect blocks
    - Allow file to grow with an additional 1024*1024 or 1 million 4KB blocks
- **Triple indirect pointer** points to a block that contains double indirect blocks
- Multi-Level Index approach to pointing to file blocks
    - Ex: twelve direct pointers, a single and a double indirect block
        - over 4GB in size $(12 + 1024 + 1024^2)$ * 4KB
- Many file system use a multi-level index
    - Linux EXT2, EXT3, NetApp's WAFL, Unix file system
    - Linux EXT4 use **extents** instead of simple pointers