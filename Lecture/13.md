# Conditional Variables
- There are many cases where a thread wishes to <u>check</u> whether a **condition** is true before continuing its execution
- Example
    - A parent thread might wish to check whether a child thread has *completed*
    - This is often called a `join()`

- A parent waiting for its child
    ```c
    void *child(void *arg) {
        printf("child\n");
        // XXX how to indicate we are done?
        return NULL;
    }

    int main(int argc, char *argv[]) {
        printf("parent: begin\n");
        pthread_t c;
        Pthread_create(&c, NULL, child, NULL); // create child
        // XXX how to wait for child?
        printf("parent: end\n");
        return 0;
    }

    // What we would like to see here
    // parent: begin
    // child
    // parent: end
    ```

## Parent Waiting for Child: Spin-based Approach
```c
volatile int done = 0;

void *child(void *arg) {
    printf("child\n");
    done = 1;
    return NULL;
}

int main(int argc, char *argv[]) {
    printf("parent: begin\n");
    pthread_t c;
    Pthread_create(&c, NULL, child, NULL); // create child
    while(done == 0)
        ; // spin
    printf("parent: end\n");
    return 0;
}
```
- This is hugely <u>inefficient</u> as the parent spins and **wastes CPU time**

### How to Wait for a Condition
- Condition variable
    - **Waiting** on the condition
        - <u>An explicit queue</u> that threads can put themselves on when some state of execution is not as desired
    - **Signaling** on the condition
        - Some other thread, *when it changes the state*, can wake one of those waiting threads and allow them to continue

## Definition and Routines
- Declare condition variable
    > pthread_cond_t c;
    - Proper initialization is required
- Operation (the POSIX calls)
    ```c
    pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);   // wait()
    pthread_cond_signal(pthread_cond_t *c); // signal()
    ```
    - The wait() call takes a <u>mutex</u> as a parameter
        - The wait() call releases the lock and put the calling thread to sleep
        - When the thread wakes up, it must re-acquire the lock

## Parent Waiting for Child: Using a condition variable
```c
int done = 0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t c = PTHREAD_COND_INITIALIZER;

void thr_exit() {
    pthread_mutex_lock(&m);
    done = 1;
    pthread_cond_signal(&c);
    pthread_mutex_unlock(&m);
}

void *child(void *arg) {
    printf("child\n");
    thr_exit();
    return NULL;
}

void thr_join() {
    pthread_mutex_lock(&m);
    while(done == 0)
        pthread_cond_wait(&c, &m);
    pthread_mutex_unlock(&m);
}

int main(int argc, char *argv[]) {
    printf("parent: begin\n");
    pthread_t p;
    pthread_create(&p, NULL, child, NULL);
    thr_join();
    printf("parent: end\n");
    return 0;
}
```

- Parent:
    - Create the child thread and continues running itself
    - Call into `thr_join()` to wait for the child thread to complete
        - Acquire the lock
        - Check if the child is done
        - Put itself to sleep by calling `wait()`
        - Release the lock

- Child:
    - Print the message "child"
    - Call `thr_exit()` to wake the parent thread
        - Grab the lock
        - Set the state variable `done`
        - Signal the parent thus waking it

## The Importance of the State Variable done
- Without variable `done`
```c
void thr_exit() {
    pthread_mutex_lock(&m);
    pthread_cond_signal(&c);
    pthread_mutex_unlock(&m);
}

void thr_join() {
    pthread_mutex_lock(&m);
    pthread_cond_wait(&c, &m);
    pthread_mutex_unlock(&m);
}
```
- Imagine the case where the *child runs immediately*
    - The child will signal, but there is <u>no thread asleep</u> on the condition
    - When the parent runs, it will call wait and be stuck
    - `No thread will ever wake it`

## Another Poor Implementation
```c
void thr_exit() {
    done = 1;
    pthread_cond_signal(&c);
}

void thr_join() {
    if(done == 0)
        pthread_cond_wait(&c, &m);
}
```
- The issue here is a subtle **race condition**
    - The parent calls thr_join()
        - The parent checks the value of `done`
        - It will see that it is 0 and try to go to sleep
        - *Just before* it calls wait to go to sleep, the parent is <u>interrupted</u> and the child runs
    - The child changes the state variable done to 1 and signals
        - But no thread is waiting and this no thread is woken
        - When the parent runs again, it sleeps forever

## The Producer / Consumer (Bound Buffer) Problem
- **Producer**
    - `Produce` data items
    - Wish to place data items in a buffer
- **Consumer**
    - Grab data items out of the buffer `consume` them in some way
- Example: Multi-threaded web server
    - A *producer* puts HTTP requests in to a work queue
    - Consumer *threads* take requests out of this queue and process them

### Bounded Buffer
- A bounded buffer is used when you <u>pipe the output</u> of one program into another
    - Example: `grep foo file.txt | wc -1`
        - grep: producer
        - wc: consumer
        - Between them is an in-kernel <u>bounded buffer</u>
    - Bounded buffer is Shared resource
        - **Synchronized access** is required

## Put and Get Routines (Version 1)
```c
int buffer;
int count = 0;  // initially, empty

void put(int value) {
    assert(count == 0);
    count = 1;
    buffer = value;
}

void get() {
    assert(count == 1);
    count = 0;
    return buffer;
}
```

- Only put data into the buffer when `count` is zero
    - i.e., when the buffer is *empty*
- Only get data from the buffer when `count` is one
    - i..e., when the buffer is *full*

```c
void *producer(void *arg) {
    int i;
    int loops = (int) args;
    for(i = 0; i < loops; i++) {
        put(i);
    }
}

void *consumer(void *arg) {
    int i;
    while(1) {
        int tmp = get();
        printf("%d\n", tmp);
    }
}
```
- **Producer** puts an integer into the shared buffer loops number of times
- **Consumer** gets the data out of that shared buffer

## Producer/Consumer: Single CV and If Statement
- A single condition variable `cond` and associated lock `mutex`
```c
cond_t cond;
mutex_t mutex;

void *producer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        Pthread_mutex_lock(&mutex);     // p1
        if(count == 1)      // p2
            Pthread_cond_wait(&cond, &mutex);       // p3
        put(i);     // p4
        Pthread_cond_signal(&cond);     // p5
        Pthread_mutex_unlock(&mutex);     //p6
    }
}

void *consumer(void *arg) {
    int i;
    for(i = 0; i < loops; i++) {
        Pthread_mutex_lock(&mutex);     // c1
        if(count == 0)      // c2
            Pthread_cond_wait(&cond, &mutex);       // c3
        int tmp = get();        // c4
        Pthread_cond_signal(&cond);     // c5
        Pthread_mutex_unlock(&mutex);       // c6
        printf("%d\n", tmp);
    }
}
```
- p1-p3: A producer waits for the buffer to be empty
- c1-c3: A consumer waits for the buffer to be full
- With just *a single producer* and *a single consumer*, the code works

> If we have **more than** one of producer and consumer?
