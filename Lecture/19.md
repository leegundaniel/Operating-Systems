# RAID
## RAID (Redundant Array of Inexpensive Disks)
- **Use multiple disks** in concert to build a **faster**, **bigger**, and more **reliable** disk system
    - RAID just looks like <u>a big disk</u> to the host system
- Advantage
    - **Performance & Capacity**: Using multiple disks in parallel
    - **Reliability**: RAID can tolerate the loss of a disk

> RAIDs provide these advantages **transparently** to systems that use them

## RAID Interface
- When a RAID receives I/O request,
    1. The RAID **calculates** which disk to access
    2. The RAID **issues** one or more **physical I/Os** to do so
- RAID example: A mirrored RAID system
    - Keep <u>two copies</u> of each block (each one on a separate disk)
    - Perform <u>two physical I/Os</u> for every one logical I/O it is issued

## RAID Internals
- A microcontroller
    - Run firmware to direct the operation of the RAID
- Volatile memory (such as DRAM)
    - Buffer data blocks
- Non-volatile memory
    - Buffer writes safely
- Specialized logic to perform parity calculation

## Fault Model
- RAIDs are designed to **detect** and **recover** from certain kinds of disk faults
- **Fail-stop** fault model
    - A disk can be in one of two: Working or Failed
        - Working: all blocks can be read or written
        - Failed: the disk is permanently lost
    - **RAID controller** can immediately observe when a disk has failed

## How to Evaluate a RAID
- Capacity
    - How much useful capacity is available to systems?
- Reliability
    - How many disk faults can the given design tolerate?
- Performance

## RAID Level 0: Striping
- RAID Level 0 is the simplest form as **striping** blocks
    - **Spread the blocks** across the disks in <u>a round-robin fashion</u>
    - No redundancy
    - Excellent <u>performance</u> and <u>capacity</u>

| Disk 0 | Disk 1 | Disk 2 | Disk 3 |
| -- | -- | -- | -- |
| 0 | 1 | 2 | 3 |
| 4 | 5 | 6 | 7 |
| 8 | 9 | 10 | 11 |
| 12 | 13 | 14 | 15 |

- Example: RAID-0 with a bigger chunk size
    - Chunk size: 2 blocks (8 KB)
    - A Stripe: 4 chunks (32 KB)

- Chunk size is 2 blocks

| Disk 0 | Disk 1 | Disk 2 | Disk 3 |
| -- | -- | -- | -- |
| 0 | 2 | 4 | 6 |
| 1 | 3 | 5 | 7 |
| 8 | 10 | 12 | 14 |
| 9 | 11 | 13 | 15 |

### Chunk Sizes
- Chunk size mostly affects performance of the array
    - **Small chunk size**
        - Increasing the parallelism
        - Increasing positioning time to access blocks
        - Better throughput, unstable latency
    - **Big chunk size**
        - Reducing intra-file parallelism
        - Reducing positioning time
        - Latency more stable (not faster), worse throughput
> Determining the "best" chunk size is hard to do

> Most arrays use larger chunk sizes (e.g., 64 KB)

### RAID Level 0 Analysis
- Capacity = perfect
    - Striping delivers N disks worth of useful capacity
- Performance of striping = excellent
    - All disks are utilized often in parallel
- Reliability = RAID-0 is bad
    - Any disk failure will lead to data loss

### Evaluating RAID Performance
- Consider two performance metrics
    - Single request latency
    - Steady-state throughput
- Workload
    - **Sequential**: access 1MB of data (block (B) ~ block (B + 1MB))
    - **Random**: access 4KB at random logical address
- A disk can transfer data at
    - S MB/s under a sequential workload
    - R MB/s under a random worload

#### Example
- Sequential (S) vs Random (R)
    - Sequential :transfer 10 MB on average as continuous data
    - Random: transfer 10 KB on average
    - Average seek time: 7 ms
    - Average rotational delay: 3 ms
    - Transfer rate of disk: 50 MB/s
- Results:
    - $S = \frac{\text{Amount of Data}}{\text{Time to Access}} = \frac{10MB}{210ms} = 47.62 MB/s$
    - $R = \frac{\text{Amount of Data}}{\text{Time to Access}} = \frac{10KB}{10.195ms} = 0.981 MB/s$

### Evaluating RAID-0 Performance
- Single request latency
    - Identical to that of a single disk
- Steady-state throughput
    - **Sequential** workload: N * S MB/s
    - **Random** workload: N * R MB/s

## RAID Level 1: Mirroring
- RAID Level 1 tolerates **disk failures**
    - Copy more than one of **each block** in the system
    - Copy block places <u>on a separate disk</u>

| Disk 0 | Disk 1 | Disk 2 | Disk 3 |
| -- | -- | -- | -- |
| 0 | 0 | 1 | 1 |
| 2 | 2 | 3 | 3 |
| 4 | 4 | 5 | 5 |
| 6 | 6 | 7 | 7 |
- RAID-10 (RAID 1 + 0): Mirror pairs and then stripe
- RAID-01 (RAID 0 + 1): Contain two large striping arrays, and then mirrors

### RAID-1 Analysis
- **Capacity**: RAID-1 is Expensive
    - The useful capacity of RAID-1 is N/2
- **Reliability**: RAID-1 does well
    - It can tolerate the failure of any one disk (up to N/2 failures depending on which disk fail)

### Performance of RAID-1
- <u>Two physical writes</u> to complete
    - It suffers the <u>worst-case seek and rotational delay</u> of the two request
    - Steady-state throughput
        - Sequential Write: S * N/2 MB/s
            - Each logical write must result in two physical writes
        - Sequential READ: S * N/2 MB/s
             - Each disk will only deliver half its peak bandwidth
        - Random Write: R * N/2 MB/s
            - Each logical write must turn into physical writes
        - Random READ: N * R MB/s
            - Distribute the reads across all the disks
## RAID Level 4: Saving Space with Parity
- Add a **single parity block**
    - A Parity block stores the *redundant information* for that stripe of blocks

| Disk 0 | Disk 1 | Disk 2 | Disk 3 | Disk 4 |
| -- | -- | -- | -- | -- |
| 0 | 1 | 2 | 3 | P0 |
| 4 | 5 | 6 | 7 | P1 |
| 8 | 9 | 10 | 11 | P2 |
| 12 | 13 | 14 | 15 | P3 |

- Compute parity: the XOR of all of bits

| C0 | C1 | C2 | C3 | P |
| -- | -- | -- | -- | -- |
| 0 | 0 | 1 | 1 | XOR(0,0,1,1) = 0 |
| 0 | 1 | 0 | 0 | XOR(0,1,0,0) = 1 |

- Recover from parity
    - Imagine the bit of the C2 in the first row is lost
        1. Reading the other values in that row: 0, 0, 1
        2. The parity bit is 0 -> <u>even number of 1's</u> in the row
        3. What the missing data must be: a 1

### Analysis
- **Capacity**
    - The useful capacity is (N - 1)
- **Reliability**
    - RAID-4 tolerates <u>1 disk failure</u> and no more
- **Performance**
    - Steady-state throughput
        - Sequential read: (N - 1) * S MB/s
        - Sequential write: (N - 1) * S MB/s
        - Random read: (N - 1) * R MB/s
    
| Disk 0 | Disk 1 | Disk 2 | Disk 3 | Disk 4 |
| -- | -- | -- | -- | -- |
| 0 | 1 | 2 | 3 | P0 |
| 4 | 5 | 6 | 7 | P1 |
| 8 | 9 | 10 | 11 | P2 |
| 12 | 13 | 14 | 15 | P3 |

### Random Write Performance for RAID-4
- Overwrite a block + update the parity
- **Method 1**: additive parity
    - Read in all of the other data blocks in the stripe
    - XOR those blocks with the new block (1)
    - **Problem**: the overhead scales with the number of disks
- **Method 2**: subtractive parity

| C0 | C1 | C2 | C3 | P |
| -- | -- | -- | -- | -- |
| 0 | 0 | 1 | 1 | XOR(0,0,1,1) = 0 |

- Update C2(old) -> C2(new)
    1. Read in the old data at C2 (C2(old) = 1) and the old parity (P(old) = 0)
    2. Calculate P(new):
        - if C2(new) == C2(old) -> P(new) == P(old)
        - if C2(new) != C2(old) -> Flip the old parity
- `P(new) = (C2(old) XOR C2(new)) XOR P(old)`

### Small-Write Problem
- The parity disk can be a **bottleneck**
    - Example: update blocks 4 and 13 (marked with *)

| Disk 0 | Disk 1 | Disk 2 | Disk 3 | Disk 4 |
| -- | -- | -- | -- | -- |
| 0 | 1 | 2 | 3 | P0 |
| *4 | 5 | 6 | 7 | +P1 |
| 8 | 9 | 10 | 11 | P2 |
| 12 | *13 | 14 | 15 | +P3 |

- Disk 0 and Disk 1 can be accessed in parallel
- Disk 4 <u>prevents any parallelism</u>

> RAID-4 throughput under random small writes is (R/2) MB/s (terrible)

### A I/O Latency in RAID-4
- A single read
    - Equivalent to the latency of a single disk request
- A single write
    - Two reads and then two writes
    - The reads and writes can happen <u>in parallel
- Total latency is about twice that of a single disk

## RAID Level 5: Rotating Parity
- RAID-5 **is the solution of** small write problem
    - Rotate the party blocks across drives
    - <u>Remove the parity-disk bottleneck</u> for RAID-4

| Disk 0 | Disk 1 | Disk 2 | Disk 3 | Disk 4 |
| -- | -- | -- | -- | -- |
| 0 | 1 | 2 | 3 | P0 |
| 5 | 6 | 7 | P1 | 4 |
| 10 | 11 | P2 | 8 | 9 |
| 15 | P3 | 12 | 13 | 14 |
| P4 | 16 | 17 | 18 | 19 |

### Analysis
- Capacity
    - The useful capacity for a RAID group is (N - 1)
- Reliability
    - RAID-5 tolerates 1 disk failure and no more
- Performance
    - Sequential read and write
        - Same as RAID-4
    - A single read and write request
        - Same as RAID-4
    - Random read: a little better than RAID-4
        - RAID-5 can utilize all of the disks
    - Random write: R * N/4 MB/s
        - The factor of four loss is cost of using parity-based RAID
    
## RAID Comparison: A Summary
- Table in slides
- Performance and do not care about reliability -> RAID-0 (Striping)
- Random I/O performance and Reliability -> RAID-1 (Mirroring)
- Capacity and Reliabilty -> RAID-5
- Sequential I/O and Maximize Capacity -> RAID-5